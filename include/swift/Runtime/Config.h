//===--- Config.h - Swift Language Platform Configuration -------*- C++ -*-===//
//
// This source file is part of the Swift.org open source project
//
// Copyright (c) 2014 - 2016 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See http://swift.org/LICENSE.txt for license information
// See http://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
//
//===----------------------------------------------------------------------===//
//
// Definitions of common interest in Swift.
//
//===----------------------------------------------------------------------===//

#ifndef SWIFT_RUNTIME_CONFIG_H
#define SWIFT_RUNTIME_CONFIG_H

/// Does the current Swift platform support "unbridged" interoperation
/// with Objective-C?  If so, the implementations of various types must
/// implicitly handle Objective-C pointers.
///
/// Apple platforms support this by default.
#ifndef SWIFT_OBJC_INTEROP
#ifdef __APPLE__
#define SWIFT_OBJC_INTEROP 1
#else
#define SWIFT_OBJC_INTEROP 0
#endif
#endif

/// Does the current Swift platform allow information other than the
/// class pointer to be stored in the isa field?  If so, when deriving
/// the class pointer of an object, we must apply a
/// dynamically-determined mask to the value loaded from the first
/// field of the object.
///
/// According to the Objective-C ABI, this is true only for 64-bit
/// platforms.
#ifndef SWIFT_HAS_ISA_MASKING
#if SWIFT_OBJC_INTEROP && defined(__LP64__)
#define SWIFT_HAS_ISA_MASKING 1
#else
#define SWIFT_HAS_ISA_MASKING 0
#endif
#endif

// We try to avoid global constructors in the runtime as much as possible.
// These macros delimit allowed global ctors.
#if __clang__
# define SWIFT_ALLOWED_RUNTIME_GLOBAL_CTOR_BEGIN \
    _Pragma("clang diagnostic push") \
    _Pragma("clang diagnostic ignored \"-Wglobal-constructors\"")
# define SWIFT_ALLOWED_RUNTIME_GLOBAL_CTOR_END \
    _Pragma("clang diagnostic pop")
#else
# define SWIFT_ALLOWED_RUNTIME_GLOBAL_CTOR_BEGIN
# define SWIFT_ALLOWED_RUNTIME_GLOBAL_CTOR_END
#endif

// Bring in visibility attribute macros
#include "../../../stdlib/public/SwiftShims/Visibility.h"

// Define mappings for calling conventions.

// Annotation for specifying a calling convention of
// a runtime function. It should be used with declarations
// of runtime functions like this:
// void runtime_function_name() CALLING_CONVENTION(RegisterPreservingCC)
#define CALLING_CONVENTION(CC) CALLING_CONVENTION_##CC

#define CALLING_CONVENTION_preserve_most __attribute__((preserve_most))
#define CALLING_CONVENTION_preserve_all  __attribute__((preserve_all))
#define CALLING_CONVENTION_c

// Map a logical calling convention (e.g. RegisterPreservingCC) to LLVM calling
// convention.
#define LLVM_CC(CC) LLVM_CC_##CC

// Currently, RuntimeFunction.def uses the following calling conventions:
// DefaultCC, RegisterPreservingCC.
// If new runtime calling conventions are added later, they need to be mapped
// here to something appropriate.

// DefaultCC is usually the standard C calling convention.
#define CALLING_CONVENTION_DefaultCC CALLING_CONVENTION_c
#define CALLING_CONVENTION_DefaultCC_IMPL CALLING_CONVENTION_c
#define LLVM_CC_DefaultCC llvm::CallingConv::C

// If defined, it indicates that runtime function wrappers
// should be used on all platforms, even they do not support
// the new calling convention which requires this.
#define RT_USE_WRAPPERS_ALWAYS 1

// If defined, it indicates that this calling convention is
// supported by the currnet target.
// TODO: Define it once the runtime calling convention support has
// been integrated into clang and llvm.
//#define RT_USE_RegisterPreservingCC

// RegisterPreservingCC is a dedicated runtime calling convention to be used
// when calling the most popular runtime functions.
#if defined(RT_USE_RegisterPreservingCC) && __has_attribute(preserve_most) &&  \
    (defined(__aarch64__) || defined(__x86_64__))

// Targets supporting the dedicated runtime convention should use it.
// If a runtime function is using this calling convention, it can
// be invoked only by means of a wrapper, which performs an indirect
// call. Wrappers are generated by the IRGen and added to object files.
// As a result, runtime functions are invoked only indirectly from
// the user code.
// This is a workaround for dynamic linking issues, where a dynamic
// linker may clobber some of the callee-saved registers defined by
// this new calling convention when it performs lazy binding of
// runtime functions using this new calling convention.
#define CALLING_CONVENTION_RegisterPreservingCC CALLING_CONVENTION_preserve_most
#define CALLING_CONVENTION_RegisterPreservingCC_IMPL                           \
  CALLING_CONVENTION_preserve_most
#define LLVM_CC_RegisterPreservingCC llvm::CallingConv::PreserveMost

// Indicate that wrappers should be used, because it is required
// for the calling convention to get around dynamic linking issues.
#define RT_USE_WRAPPERS 1

#else

// Targets not supporting the dedicated runtime calling convention
// should use the standard calling convention instead.
// No wrappers are required in this case by the calling convention.
#define CALLING_CONVENTION_RegisterPreservingCC CALLING_CONVENTION_c
#define CALLING_CONVENTION_RegisterPreservingCC_IMPL CALLING_CONVENTION_c
#define LLVM_CC_RegisterPreservingCC llvm::CallingConv::C

#endif

// Bring in visibility attribute macros for library visibility.
#include "llvm/Support/Compiler.h"

// Generates a name of the runtime enrty's implementation by
// adding an underscore as a prefix and a suffix.
#define RT_ENTRY_IMPL(Name) _##Name##_

// Library internal way to invoke the implementation of a runtime entry.
// E.g. a runtime function  may be called internally via its public API
// or via the function pointer.
#define RT_ENTRY_CALL(Name) Name

// Name of the symbol holding a reference to the
// implementation of a runtime entry.
#define RT_ENTRY_REF(Name) _##Name

// String representation of the symbol's name.
#define RT_ENTRY_REF_AS_STR(Name) "_" #Name

#if defined(RT_USE_WRAPPERS_ALWAYS)
#define RT_USE_WRAPPERS
#endif

#if defined(RT_USE_WRAPPERS)

// Both the runtime functions and their implementation are hidden and
// can be directly referenced only inside the runtime library.
// User code can access these runtime entries only indirectly
// via a global function pointer.
#define RT_ENTRY_VISIBILITY LLVM_LIBRARY_VISIBILITY
#define RT_ENTRY_IMPL_VISIBILITY LLVM_LIBRARY_VISIBILITY

#else

// Runtime functions are exported, because it should be possible
// to invoke them directly from the user code. But internal
// implementations of runtime functions do not need to be exported.
#define RT_ENTRY_VISIBILITY SWIFT_RUNTIME_EXPORT
#define RT_ENTRY_IMPL_VISIBILITY LLVM_LIBRARY_VISIBILITY

#endif

#endif // SWIFT_RUNTIME_CONFIG_H
